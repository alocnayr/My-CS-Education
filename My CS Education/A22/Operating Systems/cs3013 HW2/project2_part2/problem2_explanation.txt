Part 2 compile code: gcc -g hw1part2.c -o part_2
Project 2 part 2 explanation:

In this part I used many printf to check my output of my code to see if the numbers made sense (if all the planes have distinct IDs, there is variation in plane size, it is clear that they all pick a random runway sequence that corresponds their size, and so on). In this problem, I used 6 different semaphores, each corresponding to their own runway. I found this to be the most efficient way of implementing a runway system without having a deadlock, where there is only one semaphore and multiple planes waiting on the one semaphore. This, in my mind, sounds very inefficient, so I implemented multiple semaphores, so that if two big planes wanted to take off from 1,4,6 and 5,3,2 , then they would be able to do so, making this runway system more optimized. I made 2 2d arrays of all runway comparisons for large and small planes and made a helper function to pick a random set in this 2d array and do two things with it. Determine based on their size which 2d array youâ€™d use, and then get a random number to determine which set to use and another random number to do a coin flip whether you should reverse the order of the runways or not. I then tell the corresponding airplane threads to wait on that semaphore corresponding to each runway and make them wait on all of them and get them before they get to take off on their runways. I make them sleep for a random amount of time between (rand()%100) and I manipulated this random time and made it much smaller and larger to see if how it affected my output. After the airplane wakes up from its sleep, it moves on the next runway and releases the semaphore, allowing for someone else to take it. Then the airplane is in the air and sleeps for a random amount of time, and again, I changed the random time multiple times to see if it affected my output. Awaiting landing and landing are pretty much the same as takeoff; just fetching the random runways and semaphores corresponding to each.