(Description of the project itself is in the README.txt)

1. the overall strategy (include explanation for game time variablity and bounds, and pre-game napping)
We used the pthread_mutex lock for this problem, and the process can be terminated using keyboard interrupt. 

Looking at the overall architecture, we have 2 different self-defined structures: park and player_about; one containing information about the park and one about each individual players. The park contains a lock, the current sport it is hosting (0=none, 1=baseball, 2=football, 3=soccer), the current number of player it is hosting, and the current number of soccer players it is hosting. On the other hand, each player has its unique id, the sport it plays, its field slot (1~18), and it's status, indicating whether it is on field or not. 

We also have several global varaibles to help us keeping track of what's going on in the field. We have a counter for each sport, indicating how many players are ready at a time. We also have an array of player pointers for each sport, keeping track of which players are ready. The park and the player array containing all players is also declared globally. We have a global lock that takes care of locking aside from the lock in the park, and three condition varaibles for each sport and another condition variable for general conditions.

In regards to function, the main function reads in the seed file and create all the threads and assign the player type based on their ID. The init function initiate the condition of the park. The go_in function allows the sport switching to happen, where it determine which type of sport will be played on field based on the player's sport type. The get_out function resets the park parameters to zero (no more sports and no more players). The end funtion simply destroys the lock after everything is done.

The player_init function oversees the entire process of the game. Starting at the beginnning of the process, there will be two random number generated, one for the sleep time before threads get ready and one for the game time. Then the thread will proceed to get ready, setting it's status to 0 (not on field). Then, each player will get to ready state after a random amount of sleep time. Each thread goes to sleep until there are enough number of players to join the field, then it gets its field ID and its status changed to 1 (on field). After game, the last player who wakes everyone up will also hand the field ID to the next sport who is ready (reference to the dinning philosopher problem). Note that if both sports are ready, there will be a random selection between two sports. Then, the next sport declares their entrance, and the last players set their status and their field ID back to 0, indicating they are no longer in field and keep looping. The program locks the critical regions that access the global variables to make sure that no data is alternated in undesired way.
 
2. how to make soccer players join with limit (maximize parallelism but also meeting field maxima)
Looking at the if statement and the while loop for "waiting for other players to join" section. The while loop makes sure that as long as two soccer players are ready, add them to the field. The if statement makes sure that only the first 22 players that are ready can join the field. This is secured again in the go_in function, where the case of soccer players wanting to join has a special if statment, making sure that the value is less than 22.

3. how to make sure that the other types of player does not exceed the field limit (maximize parallelism but also meeting field maxima and minimaï¼‰
To make sure that not all threads of the same sport will be waken up at the same time thus exceeding the field limit, we have the while loop for wait set up such that once it reaches the max limit number of players, the last thread will go ahead and remind the previous sport to finish up, allowing their entrance. Thus, all players that are ready after that statement will still be waiting for the next set of players to get into the field. 

4. how to make sure there is only one team on field at a time (Team safety)
To make sure that only one type of player is on field at a time, we assigned a specific lock to the park, and we also locked around the enter, play, and leave process to make sure that only one type of sport is on the field. We also only wake players up once they have an entire team or pair (soccer in this case) ready. With the exception of soccer players able to join mid-game to other soccer games, please refer to part2 of the explanation.

5. how to make sure not depriving other type of players from playing (fair performace opportunities)
To make sure not depriving other types of sport from playing, once enough players are ready for a sport, it will wait for the last pair of soccer players on field to finish their game and immediately jump in after they finish (can be seen in example code). That last thread serves as a "messenger" to both wake up the players waiting for the signal and set their state to ready. We also let the last ready player within the group to hand field ID to the next set of players before leaving the field so that they do not get interrupted mid-game. 
